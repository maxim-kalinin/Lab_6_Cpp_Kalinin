#include "Task1.h"


void functionZadanie1()
{

cout<< "=========================================================================" <<endl;
cout<< "                            Задание 1.                                   " <<endl;
cout<< "=========================================================================" <<endl;
cout<<endl;
cout << "Заполните таблицы 1 и 2, систематизирующие информацию о классах STL." <<endl;
cout<<endl<<endl;
cout<< "                                 Таблица 1."<<endl<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Название класса  |  Массив (array)  |  Вектор (vector)  |  Список (list)    |"<<endl;
cout<<"|                  |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Какую библиотеку |     <array>      |     <vector>      |     <list>        |"<<endl;
cout<<"| подключить       |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  |                  |  vector<int> vect |  list<int,3> lst  |"<<endl;
cout<<"| Синтаксис        | array<int,3> arr |  = { 11,22,33 };  |  = { 11,22,33 };  |"<<endl;
cout<<"| инициализации    |  = { 11,22,33 }  |                   |                   |"<<endl;
cout<<"|                  |                  | vect.push_back(1) |  lst.push_back()  |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Какими способами |   по индексу     |   по индексу      |   по итератору    |"<<endl;
cout<<"| можно получить   |                  |                   | list<int>::       |"<<endl;
cout<<"| доступ к элемен- |   arr[i]         |    vect[i]        | iterator it =     |"<<endl;
cout<<"| ту класса?       |   arr.at(i)      |    vect.at(i)     | lst.begin();      |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  |                  |                   | Можно. В любое    |"<<endl;
cout<<"| Можно ли доб-ять | Можно. В любое   | Можно. В любое    | место при помощи  |"<<endl;
cout<<"| новые элементы.  | место при помощи | место при помощи  | итератора.        |"<<endl;
cout<<"| Каким образом.   | индекса.         | индекса.          | В начало списка:  |"<<endl;
cout<<"| С какой стороны. |                  |                   | list.push_front() |"<<endl;
cout<<"|                  |                  |                   | В конец списка:   |"<<endl;
cout<<"|                  |                  |                   | list.push_back()  |"<<endl;
cout<<"|                  |                  |                   | По итератору:     |"<<endl;
cout<<"|                  |                  |                   | list.insert(it,0) |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  |                  |                   | Можно. В любом    |"<<endl;
cout<<"| Можно ли удалять | Можно. В любое   | Можно. В любое    | месте при помощи  |"<<endl;
cout<<"| элементы.        | место при помощи | место при помощи  | итератора.        |"<<endl;
cout<<"| Каким образом.   | индекса.         | индекса.          | В начале списка:  |"<<endl;
cout<<"| С какой стороны. |                  |                   | list.pop_front()  |"<<endl;
cout<<"|                  |                  |                   | В конце списка:   |"<<endl;
cout<<"|                  |                  |                   | list.pop_back()   |"<<endl;
cout<<"|                  |                  |                   | По итератору:     |"<<endl;
cout<<"|                  |                  |                   | std::advance(it,3)|"<<endl;
cout<<"|                  |                  |                   | list.erase(it)    |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Каким способом   |                  |                   |                   |"<<endl;
cout<<"| узнать кол-во    |  array.size();   |  vector.size();   |  list.size();     |"<<endl;
cout<<"| эл-тов в классе? |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Имееет ли класс  | Не предлагает.   | Не предлагает.    | Да есть.          |"<<endl;
cout<<"| автоматическую   | Использ. метод:  | Использ. метод:   | Использ. метод:   |"<<endl;
cout<<"| сорт-вку данных  | std::sort();     | std::sort();      | std::list::sort   |"<<endl;
cout<<"| Если да, какую?  |                  |                   | list.sort();      |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| При каком ус-вии |                  |                   |                   |"<<endl;
cout<<"| объект класса    | Всегда может.    | Всегда может.     | Всегда может.     |"<<endl;
cout<<"| может содержать  |                  |                   |                   |"<<endl;
cout<<"| два или более    |                  |                   |                   |"<<endl;
cout<<"| один-вых значен? |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  | Получить элемент | Получить элемент  | Добавить значение |"<<endl;
cout<<"| Какие специф-ные | perem = array[i] | perem = vector[i] | в конец списка    |"<<endl;
cout<<"| функции можно    | Изменить элемент | Изменить элемент  | push_back(val)    |"<<endl;
cout<<"| прим-ть к классу.| array[i] = perem | array[i] = perem  | В начало списка   |"<<endl;
cout<<"| Что они делают?  |                  |                   | push_front(val)   |"<<endl;
cout<<"|                  | Первый элемент   | Первый элемент    | Вставить элемент  |"<<endl;
cout<<"|                  | p = arr.front()  | per = vect.front()| по итератору      |"<<endl;
cout<<"|                  | Последний эле-нт | Последний элемент | insert(iter,val)  |"<<endl;
cout<<"|                  | p = arr.back()   | per = vect.back() | Удалить элемент   |"<<endl;
cout<<"|                  |                  |                   | по итератору      |"<<endl;
cout<<"|                  | Размер контей-ра | Размер контей-ра  | erase(iter)       |"<<endl;
cout<<"|                  | array.size();    | vector.size();    | Удалить все эл-ты |"<<endl;
cout<<"|                  |                  |                   | clear();          |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;

cout<<endl<<endl<<endl;

cout<< "                                 Таблица 2."<<endl<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Название класса  | Односв-ый список |    Дек (deque)    |      Словарь      |"<<endl;
cout<<"|                  |   forvard list   |                   |    map/multimap   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Какую библиотеку |  <forward_list>  |      <deque>      |      <map>        |"<<endl;
cout<<"| подключить       |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  |                  |                   | map<string,int>mp |"<<endl;
cout<<"| Синтаксис        |forward_list<int> |  deque<int> dque  | ={ {'bread', 30}, |"<<endl;
cout<<"| инициализации    | lst = {11,22,33} |  = { 11,22,33 };  |   {'milk', 80} }; |"<<endl;
cout<<"|                  |                  |                   | std::pair<int,str>|"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Какими способами | по итератору     | По индексу        | for(auto el: map) |"<<endl;
cout<<"| можно получить   | auto iter =      | int val = dque[i] |  el.first         |"<<endl;
cout<<"| доступ к элемен- | frvdlist.begin() | dque.front();     |  el.second        |"<<endl;
cout<<"| ту класса?       | iter++;          | dque.back();      | Так же по итерат-у|"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  | Можно.           | В начало очереди  |                   |"<<endl;
cout<<"| Можно ли доб-ять | В начало списка: | push_front(val)   | Можно.            |"<<endl;
cout<<"| новые элементы.  | lst.push_front() |                   | map.insert(pair<>)|"<<endl;
cout<<"| Каким образом.   |                  | В конец очереди   |                   |"<<endl;
cout<<"| С какой стороны. | По итератору:    | push_back(val)    | std::pair         |"<<endl;
cout<<"|                  | lst.insert(it,v) |                   | <int,char>(4,'D') |"<<endl;
cout<<"|                  |                  | вст-ет элемнт val |                   |"<<endl;
cout<<"|                  |                  | на поз-ю итерат-ра|                   |"<<endl;
cout<<"|                  |                  | insert(iter, val) |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  | Можно.           | Удаляет элемент   |                   |"<<endl;
cout<<"| Можно ли удалять | В начале списка: | на итераторе:     | Можно.            |"<<endl;
cout<<"| элементы.        | flst.pop_front() | deque.erase(iter) |                   |"<<endl;
cout<<"| Каким образом.   | После итератора: |                   | erase('milk');    |"<<endl;
cout<<"| С какой стороны. | erase_after(iter)| Удаляет первый,   |                   |"<<endl;
cout<<"|                  | Удаляет диапазон:| последний элем-ты |                   |"<<endl;
cout<<"|                  | erase_after(b,e) | pop_front()       |                   |"<<endl;
cout<<"|                  | Удал-ет все элем:| pop_back()        |                   |"<<endl;
cout<<"|                  | clear()          | Удаляет все:      |                   |"<<endl;
cout<<"|                  |                  | clear()           |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Каким способом   | Методом:         |                   |                   |"<<endl;
cout<<"| узнать кол-во    | distance(beg,end)|  deque.size();    |   map.size();     |"<<endl;
cout<<"| эл-тов в классе? |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| Имееет ли класс  |                  | Не предлагает.    | Да есть.          |"<<endl;
cout<<"| автоматическую   | Да есть.         | Использ. метод:   | Добавляемые эле-  |"<<endl;
cout<<"| сорт-вку данных  | Использ. метод:  | std::sort();      | менты, сразу      |"<<endl;
cout<<"| Если да, какую?  | frvdlist.sort(); | по итераторам     | автоматически     |"<<endl;
cout<<"|                  |                  | it.begin() it.end | сортируются.      |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"| При каком ус-вии |                  |                   | Не содержит оди-  |"<<endl;
cout<<"| объект класса    | Всегда может.    | Всегда может.     | наковых ключей.   |"<<endl;
cout<<"| может содержать  |                  |                   | Значения могут    |"<<endl;
cout<<"| два или более    |                  |                   | быть одинаковы.   |"<<endl;
cout<<"| один-вых значен? |                  |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;
cout<<"|                  | Вставляет N      | Заменя-т содер-ое |                   |"<<endl;
cout<<"| Какие специф-ные | обьектов val     | контей-ра на эле- | Проверка наличия  |"<<endl;
cout<<"| функции можно    | после итератора  | менты другого     | элемента:         |"<<endl;
cout<<"| прим-ть к классу.| insert_after     | контейнера        | map.count('aple') |"<<endl;
cout<<"| Что они делают?  | (iter, N, val)   | assign(begin,end) |                   |"<<endl;
cout<<"|                  |                  |                   | возвращает 1      |"<<endl;
cout<<"|                  | Удал-т N элем-ов | Заменя-т содер-ое | если элемент есть |"<<endl;
cout<<"|                  | начало и конец   | контей-ра N  эле- | 0 - если          |"<<endl;
cout<<"|                  | итераторов       | ментами со значе- | отсутствует.      |"<<endl;
cout<<"|                  | iter.begin()     | нием val          |                   |"<<endl;
cout<<"|                  | iter.end()       | assign(n, value)  |                   |"<<endl;
cout<<"|                  | erase_after(b,e) |                   |                   |"<<endl;
cout<<"-------------------------------------------------------------------------------"<<endl;


cout<<endl<<endl<<endl<<endl;

}

